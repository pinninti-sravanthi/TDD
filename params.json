{
  "name": "Javascript",
  "tagline": "Javscript Introduction and workshop",
  "body": "What is Javascript ?\r\n\r\nclient side scripting : \r\n> wiki : An object-oriented computer programming language commonly used to create interactive effects within web browsers\r\n\r\n![Influences](http://speakingjs.com/es5/images/spjs_0701.png)\r\n\r\n- Event-driven interaction model `vs` request-response model\r\n- Concurrent operations\r\n- Client-side JavaScript extends the core language by supplying objects to control a `Browser` and its `Document Object Model (DOM`).\r\n- Server-side JavaScript extends the core language by supplying objects relevant to running JavaScript on a `server`. \r\n  1. Communicate with a `database`\r\n  2. Provide continuity of information from one invocation to another of the application \r\n  3. Perform `file` manipulations on a server\r\n\r\nEverything in javascript is an object. Aww!!!\r\n> Act like objects. ( Explained in Literals section )\r\n\r\n`Arrays, functions`, even `numbers`! Because of this, you can do some really interesting things, such as modifying the prototypes of Objects, Arrays, etc.\r\n\r\n- Written in `c++` ( v8 chrome `c++`, Spidermonkey firefox `c++` and Rhino `java` )\r\n- primitive type ( `Boolean , Number , null , undefined and String` ( ex : `var letter = 'abc';` ) )\r\n\r\n\r\n- non-primitive ( Object, Regex and Array )\r\n>Compared by unique identity.\r\n\r\n### Topics which are covered\r\n- Primitive `vs` non-primitive\r\n- Falsy `vs` Truthy\r\n- Function and Hoisting\r\n- Scope\r\n- IIFE\r\n- Objects\r\n- Literals `vs` Wrappers and Immutable `vs` non-Immutable ( primitives section, find in primitives chapter in ebook )\r\n- Inheritance\r\n- this\r\n- Closure\r\n- Synchronous `vs` Asynchronous\r\n- Event Loop\r\n\r\n\r\n### Topics which are not covered\r\n- Object.defineProperties or propertyDescriptor and accessors.\r\n- unicode\r\n- Date\r\n- Math\r\n- Regular expressions\r\n- module loaders\r\n\r\n\r\n### 1. Primitive `vs` non-primitive\r\nPrimitive : Compared by value.\r\n- Booleans: true, false\r\n- Numbers: 1736, 1.351\r\n- Strings: 'abc', \"abc\"\r\n- Two “nonvalues”: undefined, null\r\n\r\n```javascript\r\n> 3 === 3\r\ntrue\r\n> 'abc' === 'abc'\r\ntrue\r\n```\r\n\r\nnon-primitive :\r\nAll nonprimitive values are objects. The most common kinds of objects are:\r\n- Objects (Literals)\r\n\r\n```javascript\r\n\r\n{\r\n    firstName: 'Jane',\r\n    lastName: 'Doe'\r\n}\r\n```\r\n\r\n- Arrays (Literals): \r\n\r\n```javascript\r\n['item1','item2'];\r\n\r\n```\r\n\r\ncompared by reference.\r\nIdentities are compared; every value has its own identity:\r\n```javascript\r\n> ({} === {})  // two different empty objects\r\nfalse\r\n\r\n> var obj1 = {};\r\n> var obj2 = obj1;\r\n> obj1 === obj2\r\ntrue\r\n```\r\n\r\n### non-values\r\nTo represent missing information in language.\r\n```javascript\r\nundefined\r\n```\r\n> no value, non existence or Uninitialized or missing values are reprsented as undefined\r\n\r\n```javascript\r\nnull\r\n```\r\n\r\n> null means “no object.” It is used as a nonvalue whenever an object is expected (parameters, last in a chain of objects, etc.).( no properties for both not event toString())\r\n\r\n\r\n#### 2. Falsy `vs` Truthy :\r\nWhenever JavaScript expects a boolean value (e.g., for the condition of an if statement)\r\nFalsy values in language, equality or comparision check not needed\r\n\r\n- undefined, null\r\n- Boolean: false\r\n- Number: 0, NaN\r\n- String: ''\r\n\r\n```javascript\r\nvar user = 'data'\r\nif( user != null && user != false && typeof user != object ){\r\n\tconsole.log('Do some operations..')\r\n}\r\n```\r\n\r\nSimply you can check for Truthy or falsy.\r\n\r\n```javascript\r\n\r\nvar falsyArr = [0, undefined, null, '', NaN];\r\n\r\nfalsyArr.forEach(function(element, index) {\r\n    if (element)\r\n        console.log('Truthy value : ', element);\r\n    else\r\n        console.log('Falsy value : ', element);\r\n});\r\n```\r\n\r\n- Truthy values ( Note : Object and empty array are considered to be true )\r\n\r\n```\r\nvar truthyArr = [1, -1, true, 'string', [],{},function(){},RegExp];\r\n\r\ntruthyArr.forEach(function(element, index) {\r\n    if (element)\r\n        console.log('Truthy value : ', element);\r\n    else\r\n        console.log('Falsy value : ', element);\r\n});\r\n```\r\n### Functions\r\n\r\nFunction declaration:\r\n\r\n```javascript\r\nfunction id(x) {\r\n    return x;\r\n}\r\n\r\n```\r\nInvocation or calling a function : \r\n\r\n```javascript\r\n> id('hello')\r\n'hello'\r\n```\r\nIf you don’t return anything from a function, undefined is returned (implicitly):\r\n```javascript\r\n> function f() { }\r\n> f()\r\nundefined\r\n\r\n```\r\n\r\nThe Three Roles of Functions in JavaScript\r\n- normal function\r\n- constructor\r\n- method\r\n\r\nNormal function :\r\n\r\n```javascript\r\nid('hello')\r\n```\r\n\r\nConstructor : \r\n\r\nYou can invoke a function via the `new` operator. Then it becomes a constructor.\r\n\r\n```javascript\r\nnew Date() // returns an object.\r\n\r\nfunction Person(name){\r\n    this.name = name;\r\n}\r\n\r\nvar user = new Person('kamesh');\r\nconsole.log(user);\r\n```\r\n\r\nMethod\r\nYou can store a `function` in a `property` of an `object`, which turns it into a `method` that you can invoke via that `object`. Here’s an example invocation:\r\n\r\n```javascript\r\n\r\n<obj>.<method>()\r\n\r\nvar user = {\r\n    name : 'Jane',\r\n    describe : function(){\r\n        return \"Hey it's \"+this.name+\", How May I help You\";\r\n    }\r\n}\r\n\r\nuser == <obj>\r\ndescribe == <method>\r\n\r\nuser.describe();\r\n\r\n```\r\n\r\n“Parameter” `Versus` “Argument” : \r\nThe terms `parameter` and `argument` are often used interchangeably, Parameters are used to define a function. In the following example, `param1` and `param2` are `parameters`:\r\n```javascript\r\nfunction foo(param1, param2) {\r\n    ...\r\n}\r\n```\r\n`Arguments` are used to `invoke` a function. In the following example, 3 and 7 are arguments:\r\n```javascript\r\nfoo(3, 7);\r\n```\r\n\r\nDefining Functions :\r\n\r\nThis section describes three ways to create a function:\r\n```javascript\r\nVia a function expression\r\nVia a function declaration\r\nVia the constructor Function()\r\n```\r\n\r\nAll functions are objects, instances of `Function`:\r\n```javascript\r\nfunction id(x) {\r\n    return x;\r\n}\r\nconsole.log(id instanceof Function); // true\r\n```\r\nTherefore, functions get their methods from Function.prototype.\r\n\r\nFunction Expressions : \r\n\r\n```javascript\r\nvar add = function (x, y) { return x + y };\r\nconsole.log(add(2, 3)); // 5\r\n```\r\n\r\nNamed function expressions:\r\n\r\nIt allows a function expression to refer to itself, which is useful for self-recursion:\r\n\r\n```javascript\r\nvar fac = function me(n) {\r\n    if (n > 0) {\r\n        return n * me(n-1);\r\n    } else {\r\n        return 1;\r\n    }\r\n};\r\nconsole.log(fac(3)); // 6\r\n\r\nvar fac = function(n) {\r\n    if (n > 0) {\r\n        return n * fac(n-1);\r\n    } else {\r\n        return 1;\r\n    }\r\n};\r\nconsole.log(fac(3)); // 6\r\n\r\n```\r\nNOTE : \r\n\r\n> The `name` of a `named function expression` is only accessible inside the function expression:\r\n\r\n```javascript\r\nvar repeat = function me(n, str) {\r\n    return n > 0 ? str + me(n-1, str) : '';\r\n};\r\nconsole.log(repeat(3, 'Yeah')); // YeahYeahYeah\r\nconsole.log(me); // ReferenceError: me is not defined\r\n```\r\n\r\nFunction Declarations :\r\n\r\n> A function declaration declares a new variable, creates a function object, and assigns it to the variable.\r\n\r\n```javascript\r\nfunction add(x, y) {\r\n    return x + y;\r\n}\r\n\r\n```\r\n\r\n\r\nThe Function Constructor : \r\n\r\n```\r\nvar add = new Function('x', 'y', 'return x + y');\r\nadd(2,3)\r\n\r\n```\r\n> Using Function constructor is slower than creating functions directly.\r\n\r\n### Hoisting : \r\nHoisting means “moving to the beginning of a scope.” \r\n- Function declarations are hoisted completely\r\n- variable declarations only partially.\r\n\r\n```javascript\r\nfoo();\r\nfunction foo() {  // this function is hoisted\r\n    console.log('foo function got invoked.');\r\n}\r\n```\r\n\r\n> AWW!!! How is this possible? \r\n\r\nThe reason the preceding code works is that JavaScript engines move the declaration of foo to the beginning of the scope.\r\n\r\n```javascript\r\nfunction foo() {\r\n    console.log('foo function got invoked.');\r\n}\r\nfoo();\r\n\r\nfunction foo() {\r\n    bar();  // OK, bar is hoisted\r\n    function bar() {\r\n        ...\r\n    }\r\n}\r\n\r\nfunction foo() {\r\n    bar();  // Not OK, bar is still undefined\r\n    var bar = function () {\r\n        // ...\r\n    };\r\n}\r\n\r\n```\r\n\r\nFunction expressions are not hoisted : \r\n\r\n```javascript\r\nfoo();  // TypeError: undefined is not a function\r\nvar foo = function () {\r\n    ...\r\n};\r\n```\r\n\r\nEngine Executes expression like the following.\r\n\r\n```javascript\r\nvar foo;\r\nfoo();  // TypeError: undefined is not a function\r\nfoo = function () {\r\n    ...\r\n};\r\n```\r\n\r\nGetting a `name` of function : \r\n\r\n```javascript\r\n> function f1() {}\r\n> f1.name\r\n'f1'\r\n```\r\n\r\nThe name of anonymous function expressions is the `empty` string:\r\n\r\n```javascript\r\n> var f2 = function () {};\r\n> console.log( 'name of function : '+f2.name ) ;\r\n\r\n```\r\n\r\nNamed function expressions, however, do have a name:\r\n```javascript\r\n> var f3 = function myName() {};\r\n> f3.name\r\n'myName'\r\n```\r\n\r\nWhich Is Better: A Function Declaration or a Function Expression?\r\n\r\n> Should you prefer a function declaration like the following?\r\n```javascript\r\nfunction id(x) {\r\n    return x;\r\n}\r\n```\r\n> Or the equivalent combination of a var declaration plus a function expression?\r\n```javascript\r\nvar id = function (x) {\r\n    return x;\r\n};\r\n```\r\n\r\nThey are basically the same, but function declarations have two advantages over function expressions:\r\n - hoisting\r\n - name \r\n\r\n\r\nMore Control over Function Calls: `call(), apply(), and bind()`\r\n\r\n\r\ncall `func.call(thisValue, argArray)` :\r\n```javascript\r\nvar person1 = {firstName: 'Jon', lastName: 'Kuperman'};\r\nvar person2 = {firstName: 'Kelly', lastName: 'King'};\r\n\r\nfunction say(greeting) {\r\n    console.log(greeting + ' ' + this.firstName + ' ' + this.lastName);\r\n}\r\n\r\nsay.call(person1, 'Hello'); // Hello Jon Kuperman\r\nsay.call(person2, 'Hello'); // Hello Kelly King\r\n```\r\n\r\nApply : `func.apply(thisValue, argArray)` : \r\n\r\n```javascript\r\nExample 1 : \r\nvar person1 = {firstName: 'Jon', lastName: 'Kuperman'};\r\nvar person2 = {firstName: 'Kelly', lastName: 'King'};\r\n \r\nfunction say(greeting) {\r\n    console.log(greeting + ' ' + this.firstName + ' ' + this.lastName);\r\n}\r\n \r\nsay.apply(person1, ['Hello']); // Hello Jon Kuperman\r\nsay.apply(person2, ['Hello']); // Hello Kelly King\r\n\r\nExample 2 : \r\n\r\n> Math.max(17, 33, 2)\r\n33\r\n> Math.max.apply(null, [17, 33, 2])\r\n33\r\n````\r\n\r\nBind : \r\n\r\nCreates a partial function or returns a new functions.\r\n\r\n> func.bind(thisValue, arg1, ..., argN)\r\n\r\n```javascript\r\nex 1: \r\nfunction add(x, y) {\r\n    return x + y;\r\n}\r\nvar plus1 = add.bind(null, 1);\r\nconsole.log(plus1(5));  // 6\r\n```\r\n\r\nIn other words, we have created a new function that is equivalent to the following code:\r\n\r\n```javascript\r\nfunction plus1(y) {\r\n    return add(1, y);\r\n}\r\n\r\nex 2: \r\nvar person1 = {firstName: 'Jon', lastName: 'Kuperman'};\r\nvar person2 = {firstName: 'Kelly', lastName: 'King'};\r\n \r\nfunction say() {\r\n    console.log('Hello ' + this.firstName + ' ' + this.lastName);\r\n}\r\n \r\nvar sayHelloJon = say.bind(person1);\r\nvar sayHelloKelly = say.bind(person2);\r\n \r\nsayHelloJon(); // Hello Jon Kuperman\r\nsayHelloKelly(); // Hello Kelly King\r\n\r\n\r\n```\r\n\r\n\r\n\r\n### Scope\r\nDeclaring a Variable\r\nIn JavaScript, you declare a variable via a var statement before you use it:\r\n```javascript\r\nvar foo;\r\nfoo = 3; // OK, has been declared\r\nbar = 5; // not OK, an undeclared variable\r\n```\r\nYou can also combine a declaration with an assignment, to immediately initialize a variable:\r\n```javascript\r\nvar foo = 3;\r\n```\r\nThe value of an uninitialized variable is undefined:\r\n```javascript\r\n> var x;\r\n> x\r\n\r\nundefined\r\n```\r\n\r\nThe scope of a variable\r\nThe scope of a variable are the locations where it is `accessible`. For example:\r\n```javascript\r\nfunction foo() {\r\n    var x;\r\n}\r\n```javascript\r\nHere, the direct scope of x is the function foo().\r\n\r\nNested :\r\n\r\n```javascript\r\nfunction foo(arg) {\r\n    function bar() {\r\n        console.log('arg: '+arg);\r\n    }\r\n    bar();\r\n}\r\nconsole.log(foo('hello')); // arg: hello\r\n\r\n```\r\nShadowing :\r\n```javascript\r\nvar x = \"global\";\r\nfunction f() {\r\n    var x = \"local\";\r\n    console.log(x); // local\r\n}\r\nf();\r\nconsole.log(x); // global\r\n```\r\n\r\nVariables Are Function-Scoped\r\nMost mainstream languages are `block-scoped`: variables “live inside” the innermost surrounding code block. Here is an example from Java:\r\n```java\r\npublic static void main(String[] args) {\r\n    { // block starts\r\n        int foo = 4;\r\n    } // block ends\r\n    System.out.println(foo); // Error: cannot find symbol\r\n}\r\n```\r\n\r\nIn contrast, JavaScript’s variables are `function-scoped`: only functions introduce new scopes; blocks are ignored when it comes to scoping. For example:\r\n```javascript\r\nfunction main() {\r\n    { // block starts\r\n        var foo = 4;\r\n    } // block ends\r\n    console.log(foo); // 4\r\n}\r\n( Note : ES6 changed them `let` & 'const')\r\n```\r\n\r\nVariable Hoisting:\r\n```javascript\r\n\r\nfunction f() {\r\n    console.log(bar);  // undefined\r\n    var bar = 'abc';\r\n    console.log(bar);  // abc\r\n}\r\n\r\nfunction f() {\r\n    var bar;\r\n    console.log(bar);  // undefined\r\n    bar = 'abc';\r\n    console.log(bar);  // abc\r\n}\r\n\r\n\r\n> var x = 123;\r\n> var x;\r\n> x\r\n123\r\n\r\n```\r\n\r\n### IIFE Immediately invoked function expression (IIFE, pronounced “iffy”)\r\n- It is immediately invoked\r\n- It must be an expression\r\n- The trailing semicolon is required\r\n\r\n```javascript\r\nfunction f() {\r\n    if (condition) {\r\n        var tmp = ...;\r\n        ...\r\n    }\r\n    // tmp still exists here\r\n    // => not what we want\r\n}\r\n\r\nfunction f() {\r\n    if (condition) {\r\n        (function () {  // open block\r\n            var tmp = ...;\r\n            ...\r\n        }());  // close block\r\n    }\r\n}\r\n\r\n(function () { // open IIFE\r\n    // inside IIFE\r\n}()); // close IIFE\r\n\r\n```\r\n\r\nIIFE with params : \r\n```javascript\r\nvar x = 23;\r\n(function (twice) {\r\n    console.log(twice);\r\n}(x * 2));\r\n```\r\n\r\n> Best Practice: Avoid Creating Global Variables\r\n\r\n> your code, built-ins, analytics code, social media buttons, and so on.\r\n\r\n\r\n```javascript\r\n<!-- Don’t do this -->\r\n<script>\r\n    // Global scope\r\n    var tmp = generateData();\r\n    processData(tmp);\r\n    persistData(tmp);\r\n</script>\r\n```\r\nThe variable tmp becomes global, because its declaration is executed in global scope. But it is only used locally. Hence, we can use an IIFE (see Introducing a New Scope via an IIFE) to hide it inside a nested scope:\r\n```javascript\r\n<script>\r\n    (function () {  // open IIFE\r\n        // Local scope\r\n        var tmp = generateData();\r\n        processData(tmp);\r\n        persistData(tmp);\r\n    }());  // close IIFE\r\n</script>\r\n```\r\n### Objects\r\nAll nonprimitive values are objects. The most common kinds of objects are:\r\nPlain objects, which can be created by object literals (see Single Objects):\r\n```javascript\r\n{\r\n    firstName: 'Jane',\r\n    lastName: 'Doe'\r\n}\r\n```\r\nThe preceding object has two properties: the value of property firstName is 'Jane' and the value of property lastName is 'Doe'.\r\n\r\nArrays, which can be created by array literals (see Arrays):\r\n```javascript\r\n[ 'apple', 'banana', 'cherry' ]\r\n```\r\nThe preceding array has three elements that can be accessed via numeric indices. For example, the index of 'apple' is 0.\r\nRegular expressions, which can be created by regular expression literals (see Regular Expressions):\r\n```javascript\r\n/^a+b+$/\r\n```\r\n\r\nSingle Object , each property is a (key, value) pair\r\n```javascript\r\nvar jane = {\r\n    name: 'Jane',\r\n\r\n    describe: function () {\r\n        return 'Person named '+this.name;\r\n    }\r\n};\r\n\r\nDot Operator (.): Accessing Properties via Fixed Keys\r\n\r\n```javascript\r\n\tjane.name // 'Jane'\r\n\tjane.describe(); // 'Person named Jane';\r\n\r\n```\r\n\r\nArbitrary Property Keys : \r\n\r\n```javascript\r\n> var obj = { 'not an identifier': 123 };\r\n> obj['not an identifier']\r\n123\r\n> obj['not an identifier'] = 456;\r\n```\r\n\r\nExtracting Methods : \r\nIf you extract a method, it loses its connection with the object.\r\n```javascript\r\n\r\nvar jane = {\r\n    name: 'Jane',\r\n\r\n    describe: function () {\r\n        return 'Person named '+this.name;\r\n    }\r\n};\r\n\r\nvar func = jane.describe;\r\nfunc()\r\nTypeError: Cannot read property 'name' of undefined\r\n\r\nsol :\r\n\r\nvar func2 = jane.describe.bind(jane);\r\nfunc2()\r\n'Person named Jane'\r\n\r\n```\r\n\r\nGetting properties\r\n\r\nThe dot operator lets you “get” a property (read its value). Here are some examples:\r\n```javascript\r\n> jane.name  // get property `name`\r\n'Jane'\r\n> jane.describe  // get property `describe`\r\n[Function]\r\n```\r\nGetting a property that doesn’t exist returns undefined:\r\n```javascript\r\n> jane.unknownProperty\r\nundefined\r\n\r\n```\r\n\r\nCalling methods\r\n\r\nThe dot operator is also used to call methods:\r\n```javascript\r\n> jane.describe()  // call method `describe`\r\n'Person named Jane'\r\n```\r\n\r\nSetting properties\r\n\r\nYou can use the assignment operator (=) to set the value of a property referred to via the dot notation. For example:\r\n```javascript\r\n> jane.name = 'John';  // set property `name`\r\n> jane.describe()\r\n'Person named John'\r\n```\r\nIf a property doesn’t exist yet, setting it automatically creates it. If a property already exists, setting it changes its value.\r\n\r\nDeleting properties\r\n\r\nThe delete operator lets you completely remove a property (the whole key-value pair) from an object. For example:\r\n```javascript\r\n> var obj = { hello: 'world' };\r\n> delete obj.hello\r\ntrue\r\n> obj.hello\r\nundefined\r\n\r\n```\r\n\r\nBracket Operator ([]): Accessing Properties via Computed Keys :\r\n```javascript\r\n\r\n> var obj = { someProperty: 'abc' };\r\n\r\n> obj['some' + 'Property']\r\n'abc'\r\n\r\n> var propKey = 'someProperty';\r\n> obj[propKey]\r\n'abc'\r\n\r\nGetting props:\r\n> var obj = { 'not an identifier': 123 };\r\n> obj['not an identifier']\r\n123\r\n\r\ncalling methods :\r\n> var obj = { myMethod: function () { return true } };\r\n> obj['myMethod']()\r\ntrue\r\n\r\nsetting props :\r\n> var obj = {};\r\n> obj['anotherProperty'] = 'def';\r\n> obj.anotherProperty\r\n'def'\r\n\r\ndeleting props:\r\n> var obj = { 'not an identifier': 1, prop: 2 };\r\n> Object.keys(obj)\r\n[ 'not an identifier', 'prop' ]\r\n> delete obj['not an identifier']\r\ntrue\r\n> Object.keys(obj)\r\n[ 'prop' ]\r\n\r\n\r\n```\r\n\r\n\r\nObjects via Constructor \r\n\r\n```javascript\r\nfunction Person(name){\r\n\tthis.name = name;\r\n}\r\n\r\nPerson.prototype.describe = function(){\r\n\treturn 'Person named '+this.name;\r\n}\r\n\r\nvar jane = new Person('Jane');\r\n```\r\n### Literals vs Wrapper functions.\r\n\r\n- Primitives are immutable, compared by value ( undefined, null, boolean, string and number )\r\n- non-primitives are mutable ( properties can be added or deleted ), compared by identity rather than value.\r\n\r\nIn JavaScript there are 5 primitive types: `undefined, null, boolean, string` and `number`. Everything else is an object. \r\n\r\n```javascript\r\ntypeof true; //\"boolean\"\r\ntypeof Boolean(true); //\"boolean\"\r\ntypeof new Boolean(true); //\"object\"\r\ntypeof (new Boolean(true)).valueOf(); //\"boolean\"\r\n \r\ntypeof \"abc\"; //\"string\"\r\ntypeof String(\"abc\"); //\"string\"\r\ntypeof new String(\"abc\"); //\"object\"\r\ntypeof (new String(\"abc\")).valueOf(); //\"string\"\r\n \r\ntypeof 123; //\"number\"\r\ntypeof Number(123); //\"number\"\r\ntypeof new Number(123); //\"object\"\r\ntypeof (new Number(123)).valueOf(); //\"number\"\r\n\r\n```\r\nIf primitives have no properties, why does \"abc\".length return a value?\r\n\r\n```javascript\r\nvar a = \"abc\";\r\na.length\r\n// actual happening\r\n(new String('abc')).length\r\n// intermediate object gets destructed\r\n\r\n\r\nvar primitive = \"september\";\r\nprimitive.vowels = 3;\r\n//new object created to set property \r\n(new String(\"september\")).vowels = 3;\r\n \r\nprimitive.vowels;\r\n//another new object created to retrieve property \r\n(new String(\"september\")).vowels; //undefined\r\n\r\n\r\nReally object is created, is there way to verify in a scientific investigation,\r\n> Yes there is, !!!!!!!!!\r\n\r\nString.prototype.returnMe= function() {\r\n    return this;\r\n}\r\n \r\nvar a = \"abc\";\r\nvar b = a.returnMe();  \r\n \r\na; //\"abc\" \r\ntypeof a; //\"string\" (still a primitive)\r\nb; //\"abc\"\r\ntypeof b; //\"object\"\r\n\r\n\r\n\r\na; //\"abc\" \r\ntypeof a; //\"string\" (still a primitive)\r\nb; //\"abc\"\r\ntypeof b; //\"object\"\r\n\r\n```\r\n### Inheritance\r\n\r\nThe Prototype Relationship Between Objects\r\n\r\nThe prototype relationship between two objects is about inheritance: every object can have another object as its prototype\r\n```javascript\r\n> __proto__ == [[Prototype]] some javscript engines support __proto__ special key for getting and setting prototype.\r\n```\r\n![prototype chain](http://speakingjs.com/es5/images/spjs_2101.png)\r\n\r\nex :\r\n```javascript\r\nvar proto = {\r\n    describe: function () {\r\n        return 'name: '+this.name;\r\n    }\r\n};\r\nvar obj = {\r\n    __proto__: proto,\r\n    name: 'obj'\r\n};\r\n\r\nvar obj2 = {\r\n    name: 'obj2'\r\n};\r\n\r\nobj.__proto__ === proto \r\nobj2.__proto__ // root Object\r\nproto.__proto__ // root Object\r\n\r\n```\r\nOverriding\r\n```javascript\r\nobj.describe = function () { return 'overridden' };\r\nobj.describe()\r\n\r\n```\r\nPrototypes are great for sharing data between objects: several objects get the same prototype, which holds all shared properties.\r\n```javascript\r\nvar jane = {\r\n    name: 'Jane',\r\n    describe: function () {\r\n        return 'Person named '+this.name;\r\n    }\r\n};\r\nvar tarzan = {\r\n    name: 'Tarzan',\r\n    describe: function () {\r\n        return 'Person named '+this.name;\r\n    }\r\n};\r\n```\r\n![prototype chain](http://speakingjs.com/es5/images/spjs_2102.png)\r\n```javascript\r\n\r\nvar PersonProto = {\r\n    describe: function () {\r\n        return 'Person named '+this.name;\r\n    }\r\n};\r\nvar jane = {\r\n    __proto__: PersonProto,\r\n    name: 'Jane'\r\n};\r\nvar tarzan = {\r\n    __proto__: PersonProto,\r\n    name: 'Tarzan'\r\n};\r\n\r\n\r\njane.describe()\r\ntarzan.describe()\r\n```\r\n\r\nObject.create \r\n```javascript\r\n>syntax\r\nObject.create(proto, propDescObj?)\r\n\r\nvar PersonProto = {\r\n    describe: function () {\r\n        return 'Person named '+this.name;\r\n    }\r\n};\r\nvar jane = Object.create(PersonProto, {\r\n    name: { value: 'Jane', writable: true }\r\n});\r\n\r\nor manually you can create them.\r\n\r\nvar jane = Object.create(PersonProto);\r\njane.name = 'Jane';\r\n```\r\nChecking Whether a Property Exists\r\n\r\n`in` operator\r\n\r\n`propKey in obj`\r\n\r\nor \r\n\r\n`<target-Object>.hasOwnProperty(propKey)`\r\n\r\nor \r\n\r\n`Object.hasOwnProperty(propKey)`\r\n\r\n\r\nFunction prototyping.\r\n```javascript\r\nfunction Person(name) {\r\n    this.name = name;\r\n}\r\nPerson.prototype.describe = function() {\r\n    return \"Person \" + this.name;\r\n};\r\n\r\nfunction Worker(name, title) {\r\n    Person.call(this, name);\r\n    this.title = title;\r\n}\r\n\r\nWorker.prototype.__proto__ = Person.prototype;\r\nWorker.prototype.describe = function() {\r\n    return this.title + \" \" + this.name;\r\n};\r\n\r\nvar user = new Worker('Kamesh','Devloper')\r\nuser instanceof Worker\r\nuser instanceof Person\r\n```\r\n\r\nES5 to help. ( Object.create setting proper prototype internal without manually\r\naltering the prototype chain )\r\n\r\n```javascript\r\nfunction Person(name) {\r\n    this.name = name;\r\n}\r\nPerson.prototype.describe = function() {\r\n    return \"Person \" + this.name;\r\n};\r\n\r\nfunction Worker(name, title) {\r\n    Person.call(this, name);\r\n    this.title = title;\r\n}\r\n\r\nWorker.prototype = Object.create(Person.prototype);\r\nWorker.prototype.describe = function() {\r\n    return this.title + \" \" + this.name;\r\n};\r\n\r\nvar user = new Worker('Kamesh','Devloper')\r\nuser instanceof Worker\r\nuser instanceof Person\r\n```\r\nHow to call super function ? is there super available in javascript\r\nNo but we can mimic it.\r\n```javascript\r\nuser.describe(); // Developer Kamesh.\r\n\r\nWorker.prototype.describe = function() {\r\n    return this.__proto__ // worker prototype\r\n    \t\t\t.__proto__ // person prototype\r\n    \t\t\t.describe.apply(this,arguments); // person describe fn.\r\n};\r\n\r\nor \r\n\r\nWorker.prototype.describe = function() {\r\n    return Person.describe.apply(this,arguments); // person describe fn.\r\n};\r\n\r\n```\r\n\r\nWhat does “this” actually mean and how is it decided?\r\n\r\n For example, if I have a class Boat(), which has a method moveBoat(), when refering to “this” inside of the moveBoat() method, we are actually accessing the newly created object of Boat().\r\n```java\r\nclass Boat{\r\n\tboolean isReady(){\r\n\t\treturn true;\r\n\t}\r\n\tpublic boolean moveBoat(){\r\n\t\treturn this.isReady(); // this refers to newly created object.\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tBoat miniTitanic = new Boat();\r\n\t\tSystem.out.println(miniTitanic.moveBoat());\r\n\t}\r\n}\r\n```\r\nhowever it is not the only rule and “this” can often refer to a different `object` from a different `execution context`\r\n\r\n> function caller determines `this` context.\r\n\r\n```javascript\r\nfunction describe(){\r\n\tconsole.log('context ',this);\r\n\tconsole.log('User was identified as '+this.name);\r\n}\r\n\r\nvar jane = {\r\n    'name': 'Jane',\r\n    'describe': describe // method\r\n};\r\nvar tarzan = {\r\n    name: 'Tarzan',\r\n    describe: describe // method;\r\n};\r\n\r\njane.describe();\r\ntarzan.describe();\r\n```\r\nor \r\n\r\n> Remember call,apply and bind. which can invoke the function\r\nwith provided context `this` and arguments.\r\n\r\n```javascript\r\nfunction describe(){\r\n\tconsole.log('context ',this);\r\n\tconsole.log('User was identified as '+this.name);\r\n}\r\n\r\nvar smith = {\r\n\tname : 'smith'\r\n}\r\n\r\nvar jane = {\r\n\tname : 'jane'\r\n}\r\n\r\ndescribe.call(smith)\r\ndescribe.apply(jane)\r\n\r\n```\r\n### Closure\r\n\r\n> The functions defined in the closure 'remember' the environment in which they were created\r\n\r\n> Each function stays connected to the variables of the functions that surround it.\r\n\r\nNormal : \r\n```javascript\r\nfunction createIncrementor(start) {\r\n\tstart++\r\n    return start;\r\n}\r\n\r\ncreateIncrementor(5) \r\n```\r\n\r\nClosure : \r\n\r\n```javascript\r\n\r\nEx-1 : \r\nfunction createIncrementor(start) {\r\n    return function () {  // (1)\r\n        return start++;\r\n    }\r\n}\r\n\r\nvar inc = createIncrementor(5);\r\n> inc() // 6\r\n> inc() // 7\r\n> inc() // 8\r\n\r\n\r\nvar obj =  {\r\n\tincrementor :  function(start){\r\n\t\treturn function () {  // (1)\r\n        \treturn start++;\r\n    \t}\r\n\t}\r\n}\r\n\r\nvar inc = obj.incrementor(5);\r\n > inc()\r\n > inc()\r\n > inc()\r\n\r\nEx-2 : \r\n\r\nfunction init() {\r\n    var name = \"Javascript\"; // name is a local variable created by init\r\n    function displayName() { // displayName() is the inner function, a closure\r\n        alert(name); // use variable declared in the parent function    \r\n    }\r\n    displayName();\r\n}\r\ninit();\r\n\r\nfunction makeFunc() {\r\n    var name = \"Javascript\";\r\n\r\n    function displayName() {\r\n        alert(name);\r\n    }\r\n    return displayName;\r\n}\r\n\r\nvar myFunc = makeFunc();\r\nmyFunc();\r\n```\r\n\r\n> We can private variables, simulating `private members` as in other programming languages \r\n\r\n```javascript\r\nEx-3 :\r\nvar counter = (function() {\r\n    var privateCounter = 0;\r\n\r\n    function changeBy(val) {\r\n        privateCounter += val;\r\n    }\r\n    return {\r\n        increment: function() {\r\n            changeBy(1);\r\n        },\r\n        decrement: function() {\r\n            changeBy(-1);\r\n        },\r\n        value: function() {\r\n            return privateCounter;\r\n        }\r\n    };\r\n})();\r\n\r\nconsole.log(counter.value()); // logs 0\r\ncounter.increment();\r\ncounter.increment();\r\nconsole.log(counter.value()); // logs 2\r\ncounter.decrement();\r\nconsole.log(counter.value()); // logs 1\r\n\r\n```\r\n\r\nCreating closures in loops: A common mistake\r\n\r\n\r\n```javascript\r\nEx-4 : \r\nvar arr = [1, 2, 3, 4, 5];\r\nvar fnArr = []\r\nfor (var i = 0; i < arr.length; i++) {\r\n    console.log(arr[i])\r\n    fnArr.push(function() {\r\n        return arr[i]\r\n    });\r\n};\r\n\r\n??? Undefined \r\n\r\nvar arr = [1, 2, 3, 4, 5];\r\nvar fnArr = []\r\nfor (var i = 0; i < arr.length; i++) {\r\n    console.log(arr[i])\r\n    fnArr.push(function() {\r\n        console.log('Index : '+i);\r\n        return arr[i]\r\n    });\r\n};\r\n\r\n\r\nfunction printAll(){\r\n\tfnArr.forEach( function(fn, index) {\r\n\t\tconsole.log('['+index+'] : '+fn())\r\n\t});\r\n}\r\n\r\nprintAll();\r\n\r\n```\r\n\r\n> Real-World Scenario while adding event handlers to DOM in for loop\r\n\r\n> Using closure , yaayy !!!\r\n\r\n```javascript\r\n\r\nvar arr = [1, 2, 3, 4, 5];\r\nvar fnArr = []\r\nfor (var i = 0; i < arr.length; i++) {\r\n    var data = arr[i];\r\n    fnArr.push(function() {\r\n        return data\r\n    });\r\n};\r\n\r\nprintAll();\r\n\r\n```\r\n\r\n> but, wait !!! why it's printing just 5\r\n\r\n```javascript\r\nvar arr = [1, 2, 3, 4, 5];\r\nvar fnArr = []\r\nfor (var i = 0; i < arr.length; i++) {\r\n    (function() {\r\n        var data = arr[i];\r\n        fnArr.push(function() {\r\n            return data\r\n        });\r\n    })();\r\n};\r\n\r\nvar arr = [1, 2, 3, 4, 5];\r\nvar fnArr = []\r\nfor (var i = 0; i < arr.length; i++) {\r\n    fnArr.push(function(index) {\r\n        return arr[index]\r\n    }.bind(null,i));\r\n};\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Synchronous Vs Asynchronous\r\n- Blocking vs non-blocking\r\n- Event Loop\r\n- Web Apis\r\n- concurrent operations\r\n\r\n> Event-driven interaction model `vs` request-response model\r\n\r\n![Events](http://www.webstepbook.com/supplements-2ed/slides/images/figure_3_event.png)\r\n\r\n\r\n```\r\n\r\nEx-1:\r\nfunction one() {\r\n    two();\r\n}\r\n\r\nfunction two() {\r\n    three();\r\n}\r\n\r\nfunction three() {\r\n   \t console.log('end');\r\n}\r\n\r\none();\r\n\r\n```\r\n\r\nClassic example of async with `setTimeout`\r\n\r\n```javascript\r\n\r\nex-2 : \r\n\r\nconsole.log('So her we are to sync vs async ');\r\nsetTimeout(function async(){\r\n    console.log('Hello folks !!!');\r\n},0);\r\nconsole.log('Wait i forgot something to say !!!');\r\n\r\nex-3 :\r\nfunction f() {\r\n  console.log(\"1\");\r\n  setTimeout(g, 0);\r\n  console.log(\"3\");\r\n  h();\r\n}\r\n\r\nfunction g() {\r\n  console.log(\"2\");\r\n}\r\n\r\nfunction h() {\r\n  console.log(\"4\");\r\n}\r\n\r\nf();\r\n\r\n\r\n```\r\n\r\nEvent Handlers  : \r\n\r\n```javascript\r\nex-4 : \r\n$.on('button', 'click', function onClick() {\r\n    setTimeout(function timer() {\r\n        console.log('You clicked the button!');    \r\n    }, 2000);\r\n});\r\n\r\n```\r\n\r\nBlocking `vs` non-blocking\r\n\r\n```node\r\nex-4 : \r\nvar fs = require('fs');\r\n \r\nvar contents = fs.readFileSync('/Volumes/HD_II/Personal/Learning/nodejs/Docpad/my-new-website/src/node/content.txt','utf8');\r\nconsole.log('File content Sync: '+contents);\r\nconsole.log('Blocking\\n');\r\n \r\n \r\nvar contents = fs.readFile('/Volumes/HD_II/Personal/Learning/nodejs/Docpad/my-new-website/src/node/content.txt','utf8', function(err,contents){\r\n   console.log('File content Async: '+contents);\r\n});\r\nconsole.log('Non-Blocking\\n');\r\n\r\n```\r\n### Further Reading :\r\n\r\n[Primitives](https://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/)\r\n\r\n[valueOf & toString](https://javascriptweblog.wordpress.com/2010/05/03/the-value-of-valueof/)\r\n\r\n[Context](http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/)\r\n\r\n[closures](http://davidshariff.com/blog/javascript-scope-chain-and-closures/)\r\n\r\n[This](http://davidshariff.com/blog/javascript-this-keyword/)\r\n\r\n[Array Like Objects](http://www.nfriedly.com/techblog/2009/06/advanced-javascript-objects-arrays-and-array-like-objects/)\r\n\r\n[GitHub](http://www.2ality.com/2010/12/javascripts-prototypal-inheritance.html)\r\n\r\n[Inheritance](http://www.2ality.com/2011/03/lightweight-javascript-inheritance-apis.html)\r\n\r\n### Simulation\r\n\r\n[Loupe simulation](http://latentflip.com/loupe)\r\n\r\n### Video \r\n\r\n[EventLoop](https://www.youtube.com/watch?v=8aGhZQkoFbQ)\r\n\r\n### Books :\r\n[Javascript Englightment](http://www.javascriptenlightenment.com/JavaScript_Enlightenment.pdf)\r\n\r\n[ES5](http://speakingjs.com/es5/index.html)\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}